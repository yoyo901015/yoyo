#include <iostream>
#include<algorithm>
using namespace std;

int E24103079(const vector < vector<char> > &, char, char);
vector<int> available(const vector < vector<char> > &table);
void remove(vector < vector<char> > &table, int row, int col);
void put(vector < vector<char> > &table, int row, int col, char disk);
int heuristic(const vector < vector<char> >&b, int row, int col, char me);
int alphabeta(int node, vector < vector<char> >&table, int depth, int alpha, int beta, bool me, char disk);
void addScore(int &, int,bool);
int E24103079(const vector < vector<char> > &b, char mydisc, char yourdisc) {
	static const char me = mydisc; //Record the disc type main function assigns for this AI. It never changes once assigned
	static const char opponent = yourdisc; //Record the disc type main function assigns for another AI. It never changes once assigned
	//'O'
	//檢查自己先攻還後攻
	//return 6;
	
	int first =0; //'o' first=false 'x'
	int column = -1;
	int point = 0;
	int max = 0;
	//Write your AI here
	vector < vector<char> > table = b; //暫時用的table用來做minimax
	vector<int>valid= available(table);
	//若為先下 則下最中間
	int n = 0;
	int check = 0;
	char disk;
	for (auto a : valid) {
		check += a;
	}
	if (check % 2 == 0) {//先手
		disk = 'O';
	}
	else {
		disk = 'X';
	}
	//判斷自己是誰
	//cout << check << endl;
	//cout << disk << endl;
	if (check == 42) {//1st round
		return 3;
	}
	//先攻
/*	char plan='a';//a為minmax b c為random
	if (disk == 'O') {
		
		//2nd round
		if (check == 40) {
			if (valid.at(3) == 4) {//best for opponent
				plan = 'a';
				return 3;
			}
			if (valid.at(2) == 5) {
				plan = 'b';
				return 3;
			}
			if (valid.at(4) == 5) {
				plan = 'b';
				return 3;
			}
			if (valid.at(1) == 5)
				return 5;
			if (valid.at(5) == 5)
				return 1;
			if (valid.at(0) == 5 || valid.at(6) == 5) {
				plan = 'c';
				return 3;//對手放的太鳥就放自己頭上
			}
		}
		if (check == 38) {//第三round
			if (valid.at(3) == 2) {//plan a
				return 3;
			}
			if (valid.at(2) == 5) {
				return 2;
			}
			if (valid.at(4) == 5) {
				return 4;
			}
			if (valid.at(1) == 5) {
				return 3;
			}
			if (valid.at(5) == 5) {
				return 3;
			}
			if (valid.at(0) == 5) {
				return 0;
			}
			if (valid.at(6) == 5) {
				return 6;
			}

		}
		if (check == 36) {//第4round
			if (valid.at(3) == 0) {//plan a
				return 2;
			}
		}
		if (check == 34) {
			if (plan == 'a'&&valid.at(1) == 5) {//對手最好
				return 5;
			}
			if (plan == 'a'&&valid.at(4) == 5) {//對手第2好
				return 4;
			}
			if (plan == 'a'&&valid.at(2) == 4) {//win
				return 1;
			}		
			if (plan == 'a'&&valid.at(6) == 5) {//win
				return 4;
			}
			if (plan == 'a'&&valid.at(5) == 5) {//win
				return 2;
			}
			if (plan == 'a'&&valid.at(0) == 5) {//下角落的話竟向 win
				return 4;
			}
		}
		if (check == 32) {

		}
	}*/
	
	int depth = 3;
	for (int node = 0; node <= 6; node++) {
		point = alphabeta(node,table, depth-1, -1000000, 1000000,true, disk);
		if (point > max) {
			max = point;
			column = node;
		}
	}
	//Write your AI here
	return column;
}
vector<int> available(const vector < vector<char> > &table) {
	vector<int> valid;
	for (int i = 0; i <= 6; i++) {
		int tmp = 0;
		for (int j = 5; j >= 0; j--) {
			if (table[j][i] == '\0') {
				tmp = j + 1;
				//cout << j << endl;
				break;
			}
		}
		valid.push_back(tmp);
	}
	return valid;
}

void put(vector < vector<char> > &tmpTable, int row, int col, char disk) {
	cout <<"put:"<< row <<" "<<col << endl;
	tmpTable[row][col] = disk;
	return;
}
void remove(vector < vector<char> > &table, int row, int col) {
	cout << "remove=>row" << row << " " << "col" << col << endl;
	table[row][col] = '\0';
	return;

}

int heuristic(const vector < vector<char> >&table, int row, int col, char disk ) {
	//檢查下這一步棋對勝利有沒有幫助
	cout << "heuristic:(" << row << "," << col << ")" << endl;
	int score = 0;
	int tmp = -1;
	int tmpCol = col;
	int my = -1;
	int oppo = 0;
	//check上下左右斜線
	bool turn = false;
	for (int i = 0; i <= 3; i++) { //右左
		//cout << "check:(" << row << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol - (i + 1);
			}
			else {
				break;
			}

		}
		if (table[row][tmpCol] == disk&&turn==false) {
			tmp++;
			tmpCol++;
			continue;
		}
		if ((tmpCol == 6 || table[row][tmpCol] != disk)&&turn==false) {
			turn = true;
			tmpCol = tmpCol -(i+1);
			continue;
		}
		if (table[row][tmpCol] == disk && turn == true) {
			tmp++;
			tmpCol--;
			continue;
		}
	}
	//cout << "tmp" << tmp << endl;
	tmpCol = col;
	turn = false;
	for (int i = 0; i <= 3; i++) { //左到右
	//	cout << "check:(" << row << "," << tmpCol << ")" << endl;
		if (tmpCol < 0|| tmpCol>6) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol + (i + 1);
			}
			else {
				break;
			}
		}
		if (table[row][tmpCol] == disk && turn == false) {
			my++;
			tmpCol--;
			continue;
		}
		if ((tmpCol == 0|| table[row][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol + (i + 1);
			continue;
		}
		if (table[row][tmpCol] == disk && turn == true) {
			my++;
			tmpCol++;
			continue;
		}
	}
	my = max(my, tmp);
	//cout << "my:" << my << endl; //my=0代表只有自己
	addScore(score, my, true);
	//上下
	turn = false;
	tmp = -1;
	my = -1;
	int tmpRow = row;
	for (int i = 0; i <= 3; i++) { //下到上
	//	cout << "check:(" << tmpRow << "," << col << ")" << endl;
		if (tmpRow < 0 || tmpRow>5) {//防越界
			if (turn == false) {
				turn = true;
				tmpRow = tmpRow - (i + 1);
				continue;
			}
			else {
				break;
			}
		}
		if (table[tmpRow][col] == disk && turn == false) {
			tmp++;
			tmpRow++;
			continue;
		}
		if ((tmpRow == 5 || table[tmpRow][col] != disk) && turn == false) {
			turn = true;
			tmpRow = tmpRow - (i + 1);
			continue;
		}
		if (table[tmpRow][col] == disk && turn == true) {
			tmp++;
			tmpRow--;
			continue;
		}
	}
	//cout << "tmp" << tmp << endl;
	turn = false;
	//cout << "上到下" << endl;
	tmpRow = row;
	for (int i = 0; i <= 3; i++) { //上到下
	//	cout << "check:(" << tmpRow << "," << col << ")" << endl;
		if (tmpRow < 0 || tmpRow>5) {//防越界
			if (turn == false) {
				turn = true;
				tmpRow = tmpRow + (i + 1);
				continue;
			}
			else {
				break;
			}
		}
		if (table[tmpRow][col] == disk && turn == false) {
			my++;
			tmpRow--;
			continue;
		}
		if ((tmpRow == 0 || table[tmpRow][col] != disk) && turn == false) {
			turn = true;
			tmpRow = tmpRow + (i + 1);
			continue;
		}
		if (table[tmpRow][col] == disk && turn == true) {
			my++;
			tmpRow++;
			continue;
		}
	}
	my = max(my, tmp);
	//cout << "my:" << my << endl; //my=0代表只有自己
	addScore(score, my, true);

	//右上左下
	my = -1;
	tmp = -1;
	turn = false;
	tmpCol = col;
	tmpRow = row;
	for (int i = 0; i <= 3; i++) { //先右上再左下
	//	cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0|| tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol - (i + 1);
				tmpRow = tmpRow + (i + 1);
				continue;
				if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
					break;

			}
			else {
				break;
			}
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			tmp++;
			tmpCol++;
			tmpRow--;
			continue;
		}
		if ((tmpCol == 6|| tmpRow ==0 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol - (i + 1);
			tmpRow = tmpRow + (i + 1);
			continue;
		}
		if (table[tmpRow][tmpRow] == disk && turn == true) {
			tmp++;
			tmpCol--;
			tmpRow++;
			continue;
		}
	}
//	cout << "tmp" << tmp << endl;

	turn = false;
	tmpCol = col;
	tmpRow = row;
	for (int i = 0; i <= 3; i++) { //先左下再右上
	//	cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol + (i + 1);
				tmpRow = tmpRow - (i + 1);
			}
			else {
				break;
			}
			if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
				break;
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			my++;
			tmpCol--;
			tmpRow++;
			continue;
		}
		if ((tmpCol == 0 || tmpRow == 5 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol + (i + 1);
			tmpRow = tmpRow - (i + 1);
			continue;
		}
		if (table[tmpRow][tmpCol] == disk && turn == true) {
			my++;
			tmpCol++;
			tmpRow--;
			continue;
		}
	}
	my = max(my, tmp);
	//cout << "my:" << my << endl; //my=0代表只有自己
	addScore(score, my, true);
	
	//右下左上
	my = -1;
	tmp = -1;
	turn = false;
	tmpCol = col;
	tmpRow = row;
	for (int i = 0; i <= 3; i++) { //先右下再左上
	//	cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol - (i + 1);
				tmpRow = tmpRow - (i + 1);
			}
			else {
				break;
			}
			if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
				break;
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			tmp++;
			tmpCol++;
			tmpRow++;
			continue;
		}
		if ((tmpCol == 6 || tmpRow == 5 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol - (i + 1);
			tmpRow = tmpRow - (i + 1);
			continue;
		}
		if (table[row][tmpRow] == disk && turn == true) {
			tmp++;
			tmpCol--;
			tmpRow--;
			continue;
		}
	}
	//cout << "tmp" << tmp << endl;
	turn = false;
	tmpCol = col;
	tmpRow = row;
	for (int i = 0; i <= 3; i++) { //先左上再右下
	//	cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol + (i + 1);
				tmpRow = tmpRow + (i + 1);
			}
			else {
				break;
			}
			if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
				break;
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			my++;
			tmpCol--;
			tmpRow--;
			continue;
		}
		if ((tmpCol == 0 || tmpRow == 0 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol + (i + 1);
			tmpRow = tmpRow + (i + 1);
			continue;
		}
		if (table[tmpRow][tmpCol] == disk && turn == true) {
			my++;
			tmpCol++;
			tmpRow++;
			continue;
		}
	}
	my = max(my, tmp);
	//cout << "my:" << my << endl; //my=0代表只有自己
	addScore(score, my, true);
	//cout << "總分" << score << endl;
	//換成算敵人了喔!!!!!!!!!!!!!!!
	//換成算敵人了喔!!!!!!!!!!!!!!!
	//換成算敵人了喔!!!!!!!!!!!!!!!

	if (disk == 'O') {
		disk = 'X';
	}
	else {
		disk = 'O';
	}
//	cout << disk << endl;
	tmp = 0;
	oppo = 0;
	tmpCol = col + 1;
	turn = false;
//	cout << "右到左" << endl;
	for (int i = 1; i <= 3; i++) { //右左
	//	cout << "check:(" << row << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol - (i+1);
			}
			else {
				break;
			}

		}
		if (table[row][tmpCol] == disk && turn == false) {
			tmp++;
			tmpCol++;
			continue;
		}
		if ((tmpCol == 6 || table[row][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol - (i+1);
			continue;
		}
		if (table[row][tmpCol] == disk && turn == true) {
			tmp++;
			tmpCol--;
			continue;
		}
	}
//	cout << "tmp" << tmp << endl;
	tmpCol = col-1;
	turn = false;
//	cout <<"左到右"<<endl;
	for (int i = 1; i <= 3; i++) { //左到右
//		cout << "check:(" << row << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol + (i + 1);
			}
			else {
				break;
			}
		}
		if (table[row][tmpCol] == disk && turn == false) {
			oppo++;
			tmpCol--;
			continue;
		}
		if ((tmpCol == 0 || table[row][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol + (i + 1);
			continue;
		}
		if (table[row][tmpCol] == disk && turn == true) {
			oppo++;
			tmpCol++;
			continue;
		}
	}
	oppo = max(oppo, tmp);
	//cout << "oppo:" << oppo << endl; //my=0代表只有自己
	addScore(score, oppo, false);
	//上下
	turn = false;
	tmp = 0;
	oppo = 0;
	tmpRow = row+1;
//	cout << "下到上" << endl;
	for (int i = 1; i <= 3; i++) { //下到上
//		cout << "check:(" << tmpRow << "," << col << ")" << endl;
		if (tmpRow < 0 || tmpRow>5) {//防越界
			if (turn == false) {
				turn = true;
				tmpRow = tmpRow - (i + 1);
				continue;
			}
			else {
				break;
			}
		}
		if (table[tmpRow][col] == disk && turn == false) {
			tmp++;
			tmpRow++;
			continue;
		}
		if ((tmpRow == 5 || table[tmpRow][col] != disk) && turn == false) {
			turn = true;
			tmpRow = tmpRow - (i + 1);
			continue;
		}
		if (table[tmpRow][col] == disk && turn == true) {
			tmp++;
			tmpRow--;
			continue;
		}
	}
	//cout << "tmp" << tmp << endl;

	turn = false;
	//cout << "上到下" << endl;
	tmpRow = row-1;
	for (int i = 1; i <= 3; i++) { //上到下
	//	cout << "check:(" << tmpRow << "," << col << ")" << endl;
		if (tmpRow < 0 || tmpRow>5) {//防越界
			if (turn == false) {
				turn = true;
				tmpRow = tmpRow + (i + 1);
				continue;
			}
			else {
				break;
			}
		}
		if (table[tmpRow][col] == disk && turn == false) {
			oppo++;
			tmpRow--;
			continue;
		}
		if ((tmpRow == 0 || table[tmpRow][col] != disk) && turn == false) {
			turn = true;
			tmpRow = tmpRow + (i + 1);
			continue;
		}
		if (table[tmpRow][col] == disk && turn == true) {
			oppo++;
			tmpRow++;
			continue;
		}
	}
	oppo = max(oppo, tmp);
//	cout << "oppo:" << oppo << endl; //my=0代表只有自己
	addScore(score, oppo, false);

	//右上左下
	oppo = 0;
	tmp = 0;
	turn = false;
	tmpCol = col+1;
	tmpRow = row-1;
	//cout << "先右上再左下" << endl;
	for (int i = 1; i <= 3; i++) { //先右上再左下
//		cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol - (i + 1);
				tmpRow = tmpRow + (i + 1);
				continue;
				if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
					break;

			}
			else {
				break;
			}
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			tmp++;
			tmpCol++;
			tmpRow--;
			continue;
		}
		if ((tmpCol == 6 || tmpRow == 0 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol - (i + 1);
			tmpRow = tmpRow + (i + 1);
			continue;
		}
		if (table[tmpRow][tmpRow] == disk && turn == true) {
			tmp++;
			tmpCol--;
			tmpRow++;
			continue;
		}
	}
	//cout << "tmp" << tmp << endl;
	turn = false;
	tmpCol = col-1;
	tmpRow = row+1;
	//cout << "先左下再右上" << endl;;
	for (int i = 1; i <= 3; i++) { //先左下再右上
	//	cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol + (i + 1);
				tmpRow = tmpRow - (i + 1);
				if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
					break;
			}
			else {
				break;
			}
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			oppo++;
			tmpCol--;
			tmpRow++;
			continue;
		}
		if ((tmpCol == 0 || tmpRow == 5 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol + (i + 1);
			tmpRow = tmpRow - (i + 1);
			continue;
		}
		if (table[tmpRow][tmpCol] == disk && turn == true) {
			oppo++;
			tmpCol++;
			tmpRow--;
			continue;
		}
	}
	oppo = max(oppo, tmp);
	//cout << "oppo:" << oppo << endl; //my=0代表只有自己
	addScore(score, oppo, false);

	//右下左上
	oppo = 0;
	tmp = 0;
	turn = false;
	tmpCol = col+1;
	tmpRow = row+1;
	//cout << "先右下再左上" << endl;
	for (int i = 1; i <= 3; i++) { //先右下再左上
//		cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol - (i + 1);
				tmpRow = tmpRow - (i + 1);
				if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
					break;
			}
			else {
				break;
			}
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			tmp++;
			tmpCol++;
			tmpRow++;
			continue;
		}
		if ((tmpCol == 6 || tmpRow == 5 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol - (i + 1);
			tmpRow = tmpRow - (i + 1);
			continue;
		}
		if (table[row][tmpRow] == disk && turn == true) {
			tmp++;
			tmpCol--;
			tmpRow--;
			continue;
		}
	}

	turn = false;
	tmpCol = col-1;
	tmpRow = row-1;
	//cout << "先左上再右下" << endl;
	for (int i = 1; i <= 3; i++) { //先左上再右下
//		cout << "check:(" << tmpRow << "," << tmpCol << ")" << endl;
		if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5) {
			if (turn == false) {
				turn = true;
				tmpCol = tmpCol + (i + 1);
				tmpRow = tmpRow + (i + 1);
				if (tmpCol < 0 || tmpCol>6 || tmpRow < 0 || tmpRow>5)//轉完後可能越界
					break;
			}
			else {
				break;
			}
		}
		if (table[tmpRow][tmpCol] == disk && turn == false) {
			oppo++;
			tmpCol--;
			tmpRow--;
			continue;
		}
		if ((tmpCol == 0 || tmpRow == 0 || table[tmpRow][tmpCol] != disk) && turn == false) {
			turn = true;
			tmpCol = tmpCol + (i + 1);
			tmpRow = tmpRow + (i + 1);
			continue;
		}
		if (table[tmpRow][tmpCol] == disk && turn == true) {
			oppo++;
			tmpCol++;
			tmpRow++;
			continue;
		}
	}
	oppo = max(oppo, tmp);
	//cout << "oppo:" << oppo << endl; //my=0代表只有自己
	addScore(score, oppo, false);

	//cout << "總分" << score << endl;



	return score;
}
int alphabeta(int node, vector < vector<char> >&table, int depth, int alpha, int beta, bool me, char disk) {//me player=1 opponent=2
	int value = 0;
	int best=0;
	int tmpVal=0;
	vector<int>valid = available(table);//找可以放的地方
	//擺放位置即為 valid.at(node),node
	char opponentDisk;
	if (disk == 'O') {
		opponentDisk = 'X';
	}
	else {
	opponentDisk = 'O';
	}
//	cout << "me?:" << me << endl;
//	cout << "disk:" << disk << endl;
//	cout << "opponentDisk:" << opponentDisk << endl;


	put(table, valid.at(node) - 1, node, disk);

	/*for (int i = 0; i <= 5; i++) {
		for (int j = 0; j <= 6; j++) {
			if (table[i][j] == '\0') {
				cout << 1;
			}
			cout << table[i][j];
		}
		cout << endl;
	}
	cout << "印完拉" << endl;*/
	
	if (depth == 0) {
		value= heuristic(table, valid.at(node)-1, node, disk);
		remove(table, valid.at(node)-1, node);
		cout << value << endl;
		return value; //回傳他該有的分數
	}
	//Alpha is the maximum lower bound of possible solutions
	//Beta is the minimum upper bound of possible solutions
	int Row = valid.at(node) - 1;
	if (me) {
		value = -100000;
		for (int i = 0; i <= 6; i++) {
		//	cout << "i:" << i << endl;
			tmpVal = alphabeta(i, table, depth - 1, alpha, beta, false, opponentDisk);
			if (value < tmpVal) {
				value = tmpVal;
				best = i;
			}
			alpha = max(alpha, value); //若有比alpha大的可能就要替換 相對小於alpha的就可以無視
			cout << "alpha:" << alpha << " beta:" << beta <<"depth"<<depth<< endl;
			//第二round爆掉了 應該要把x拿掉 然後放到下一row
			if (alpha >= beta) {
				cout << "alpha>=beta" << endl;
				break;
			}
		}
		if (depth != 0) {
			//vector<int>valid = available(table);
			remove(table, Row, node);
		}
		if (depth != 2) {
			return value;
		}
	}
	else {
		value = 100000; //找對手極小
		//for each child of node
		for (int i = 0; i <= 6; i++) {
			value = min(value, alphabeta(i, table, depth - 1, alpha, beta, true, opponentDisk));
			beta = min(beta, value);
			cout << "alpha:" << alpha << " beta:" << beta << endl;
			if (beta <= alpha) {
				cout << "beta <= alpha" << endl;
				vector<int>valid = available(table);
				//remove(table, Row, node);
				//remove(table, valid.at(node) - 1, node);
				break;
			}
		}
		if (depth != 0) {
			vector<int>valid = available(table);
			remove(table, Row, node);
		}
		if (depth != 2) {
			return value;
		}
	}
	cout << best << endl;
	return best;
}

void addScore(int & score, int num, bool me) {
	if (me) {
		switch (num) {
			case 1:
				score += 10;
				break;
			case 2:
				score += 100;
				break;
			case 3:
				score += 1000;
				break;
		}
	}
	else {
		switch (num) {
		case 1:
			score -= 11;
			break;
		case 2:
			score -= 101;
			break;
		case 3:
			score -= 1001;
			break;
		}
	}
	//cout << "score" << score << endl;

}
